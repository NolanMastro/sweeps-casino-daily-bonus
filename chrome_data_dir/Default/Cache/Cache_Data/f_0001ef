{"version":3,"file":"pubnub.018db359cede832f9d3d.js","mappings":"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","sources":["webpack://chat-web/./src/core/core_main/api/pubnub/index.ts","webpack://chat-web/./src/core/core_main/api/pubnub/constants.ts","webpack://chat-web/./src/core/core_main/pubnub/helpers/instance.ts","webpack://chat-web/./src/core/core_main/pubnub/helpers/fetchUnreadCount.ts","webpack://chat-web/./src/core/core_main/pubnub/helpers/grantToken.ts","webpack://chat-web/./src/core/core_main/pubnub/helpers/chatMessageReceived.ts","webpack://chat-web/./src/core/core_main/pubnub/events/chatMessageReceived.ts","webpack://chat-web/./src/core/core_main/pubnub/events/conversationSubscribeOperation.ts","webpack://chat-web/./src/core/core_main/pubnub/helpers/userTyping.ts","webpack://chat-web/./src/core/core_main/pubnub/events/networkStatus.ts","webpack://chat-web/./src/core/core_main/pubnub/index.ts","webpack://chat-web/./src/core/core_main/pubnub/events/chatSessionEnded.ts","webpack://chat-web/./src/core/core_main/pubnub/events/assistantSessionEnded.ts","webpack://chat-web/./src/core/core_main/pubnub/events/chatSessionUpdate.ts","webpack://chat-web/./src/core/core_main/pubnub/events/chatSessionMerged.ts","webpack://chat-web/./src/core/core_main/pubnub/events/customerDeleted.ts","webpack://chat-web/./src/core/core_main/pubnub/events/chatSessionDelete.ts","webpack://chat-web/./src/core/core_main/pubnub/events/userTyping.ts","webpack://chat-web/./src/core/core_main/api/users/index.ts","webpack://chat-web/./src/core/core_main/api/users/helpers.ts","webpack://chat-web/./src/core/core_main/pubnub/events/chatCsatSend.ts"],"sourcesContent":["import { post } from 'core_main/request';\nimport { KustomerErrorResponse } from 'globals/types';\nimport { PUBNUB_AUTH_V1_ENDPOINT, PUBNUB_AUTH_V2_ENDPOINT } from './constants';\nimport { PubnubAuthOptions } from './types';\n\nexport const createAuthForTrackingToken = (options: PubnubAuthOptions) => {\n  if (options.version === 1) {\n    return post(PUBNUB_AUTH_V1_ENDPOINT);\n  }\n  return post(PUBNUB_AUTH_V2_ENDPOINT, {\n    body: JSON.stringify({\n      authVerified: options.outboundChatEnabled,\n    }),\n  }).then((response) => {\n    return response?.data\n      ? {\n          token: response.data.attributes?.sharedKeyset?.token,\n          ttl: response.data.attributes?.ttl,\n        }\n      : undefined;\n  });\n};\n\nexport const backoffAuthCall = (\n  options: PubnubAuthOptions,\n  retryCount = 0,\n  delay = 100,\n) => {\n  return createAuthForTrackingToken(options)\n    .catch((error: KustomerErrorResponse) => {\n      const isNotPubNubNetworkFailure = error?.title !== 'PubNubNetworkFailure';\n\n      if (retryCount === 3 || isNotPubNubNetworkFailure) {\n        return Promise.reject(error);\n      }\n\n      return new Promise((resolve) => {\n        setTimeout(() => resolve(error), delay);\n      });\n    })\n    .then((res) => {\n      if (res instanceof Error)\n        return backoffAuthCall(options, retryCount + 1, delay * 4);\n      return res;\n    });\n};\n","export const PUBNUB_AUTH_V1_ENDPOINT = '/c/v1/pubnub/auth';\nexport const PUBNUB_AUTH_V2_ENDPOINT = '/c/v2/pubnub/auth';\n","import Pubnub from 'pubnub';\nimport { getTrackingTokenFromLocalStorage } from 'helpers/browser';\nimport { PublicCallback } from 'globals/types';\nimport { getStore } from 'core_main/store';\n\nexport class PubNubInstance {\n  instance: Pubnub | undefined;\n\n  constructor() {\n    const store = getStore();\n\n    const { publishKey, subscribeKey } = store.settings.sharedPubNubKeySet;\n    const { customerId } = store;\n    const trackingToken = getTrackingTokenFromLocalStorage();\n\n    if (trackingToken !== null && customerId) {\n      this.instance = new Pubnub({\n        uuid: customerId,\n        authKey: trackingToken,\n        subscribeKey,\n        publishKey,\n        restore: true,\n        ssl: true,\n      });\n    }\n  }\n\n  listChannels = (\n    listChannelsParameters: Pubnub.ListChannelsParameters,\n    cb?: PublicCallback,\n  ) => {\n    if (!this.instance) return undefined;\n\n    return this.instance?.channelGroups.listChannels(\n      listChannelsParameters,\n      (status, response) => {\n        const { error } = status;\n        if (cb && error === false) {\n          cb(response);\n        }\n      },\n    );\n  };\n\n  fetchMessages = (\n    fetchMessagesParameters: Pubnub.FetchMessagesParameters,\n    cb?: PublicCallback,\n  ) => {\n    if (!this.instance) return undefined;\n\n    return this.instance?.fetchMessages(\n      fetchMessagesParameters,\n      (status, response) => {\n        const { error } = status;\n        if (cb && error === false) {\n          cb(response);\n        }\n      },\n    );\n  };\n\n  messageCounts = (\n    messageCountsParameters: Pubnub.MessageCountsParameters,\n    cb?: PublicCallback,\n  ) => {\n    if (!this.instance) return undefined;\n\n    return this.instance?.messageCounts(\n      messageCountsParameters,\n      (status, response) => {\n        const { error } = status;\n        if (cb && error === false) {\n          cb(response);\n        }\n      },\n    );\n  };\n}\n\nlet PubNubMetaInstance: PubNubInstance | undefined;\nlet PubNubConversationInstance: PubNubInstance | undefined;\nexport const getMetaPubNub = (): PubNubInstance | undefined => {\n  if (getTrackingTokenFromLocalStorage() === null) return undefined;\n  if (!PubNubMetaInstance) {\n    PubNubMetaInstance = new PubNubInstance();\n  }\n  return PubNubMetaInstance;\n};\n\nexport const getConversationPubNub = (): PubNubInstance | undefined => {\n  if (getTrackingTokenFromLocalStorage() === null) return undefined;\n  if (!PubNubConversationInstance) {\n    PubNubConversationInstance = new PubNubInstance();\n  }\n  return PubNubConversationInstance;\n};\n\nexport const clearPubNub = () => {\n  if (PubNubMetaInstance) {\n    PubNubMetaInstance.instance?.unsubscribeAll();\n    PubNubMetaInstance = undefined;\n  }\n  if (PubNubConversationInstance) {\n    PubNubConversationInstance.instance?.unsubscribeAll();\n    PubNubConversationInstance = undefined;\n  }\n};\n\nexport const stopPubNub = () => {\n  if (PubNubMetaInstance) {\n    PubNubMetaInstance.instance?.stop();\n    PubNubMetaInstance = undefined;\n  }\n  if (PubNubConversationInstance) {\n    PubNubConversationInstance.instance?.stop();\n    PubNubConversationInstance = undefined;\n  }\n};\n\nexport const disconnect = () => {\n  // TODO remove the typecast to any when the @types/pubnub types are updated to a version that has disconnect()\n  if (PubNubMetaInstance) {\n    (PubNubMetaInstance.instance as any).disconnect();\n  }\n  if (PubNubConversationInstance) {\n    (PubNubConversationInstance.instance as any).disconnect();\n  }\n};\n\nexport const reconnect = () => {\n  if (PubNubMetaInstance) {\n    PubNubMetaInstance.instance?.reconnect();\n  }\n  if (PubNubConversationInstance) {\n    PubNubConversationInstance.instance?.reconnect();\n  }\n};\n","import { PUBNUB_MAX_CHANNELS_COUNT } from 'core/constants';\nimport { chunk } from 'core_main/globals/helpers';\nimport { ReadMessage } from 'core_main/sdk/mark_read/types';\nimport { addUnreadCountsToStore, getStore } from 'core_main/store';\nimport { UnreadCountsState } from 'core_main/types';\nimport Pubnub from 'pubnub';\nimport { getConversationPubNub, getMetaPubNub } from './instance';\nimport { KUSTOMER_APP_CHAT_SESSION_END_EVENT } from '../constants';\nimport {\n  createConversationChannelGroupString,\n  createMetaCustomerChannelString,\n} from './channelName';\n\nexport const getMessageCountsForConversations = (\n  response: Pubnub.FetchMessagesResponse,\n  metaCustomerChannelName,\n): Promise<UnreadCountsState> => {\n  const store = getStore();\n  const { settings } = store;\n  const { noHistory } = settings;\n  const { channels } = response;\n\n  const metaCustomerChannelMessages = channels[metaCustomerChannelName];\n\n  const ignoredIds =\n    noHistory && metaCustomerChannelMessages\n      ? metaCustomerChannelMessages\n          .filter((val) => {\n            return val.message.name === KUSTOMER_APP_CHAT_SESSION_END_EVENT;\n          })\n          .map((val) => val.message.data.id)\n      : [];\n\n  const channelNames = Object.keys(channels).filter((channel) => {\n    const id = channel.split('.convo-')[1];\n\n    return !channel.includes('ext-meta-cust') && !ignoredIds.includes(id);\n  });\n\n  const lastReadMessages = channelNames.reduce((acc, val) => {\n    const messages = channels[val];\n\n    const lastReadMessage = [...messages].reverse().find((val) => {\n      const { message }: { message: ReadMessage['message'] } = val;\n      return message.eventType === 'read';\n    });\n\n    if (lastReadMessage) {\n      acc.push(lastReadMessage);\n    }\n\n    return acc;\n  }, [] as ReadMessage[]);\n\n  const counts = {\n    total: 0,\n    conversations: {},\n  };\n\n  return new Promise<UnreadCountsState>((resolve) => {\n    if (!lastReadMessages.length) resolve(counts);\n\n    lastReadMessages?.forEach((val, index) => {\n      const id = val.channel.split('.convo-')[1];\n\n      const isLast = index === lastReadMessages.length - 1;\n\n      const channelName = val.channel.replace('ext-meta-convo', 'ext-convo');\n\n      getConversationPubNub()?.messageCounts(\n        {\n          channels: [channelName],\n          channelTimetokens: [val?.timetoken as string],\n        },\n        (res) => {\n          if (res && res.channels && res.channels[channelName] !== undefined) {\n            counts.conversations[id] = res.channels[channelName];\n            counts.total += res.channels[channelName];\n          } else {\n            console.warn('PubNub messageCounts failed or no data for channel:', channelName);\n            counts.conversations[id] = 0;\n          }\n          if (isLast) resolve(counts);\n        },\n      );\n    });\n  });\n};\n\nexport const fetchUnreadCount = (cb?) => {\n  const store = getStore();\n\n  const { orgId, customerId } = store;\n\n  const channelGroup = createConversationChannelGroupString(customerId, orgId);\n  const metaCustomerChannel = createMetaCustomerChannelString(\n    customerId,\n    orgId,\n  );\n\n  getConversationPubNub()?.listChannels(\n    { channelGroup },\n    (response: Pubnub.ListChannelsResponse) => {\n      if (!response || !response.channels) {\n        console.warn('PubNub listChannels failed or no channels returned');\n        if (typeof cb === 'function') cb();\n        return;\n      }\n\n      const metaChannels = response.channels.map((channel) =>\n        channel.replace('ext-convo', 'ext-meta-convo'),\n      );\n      const channelChunks = chunk(\n        [metaCustomerChannel, ...metaChannels],\n        PUBNUB_MAX_CHANNELS_COUNT,\n      );\n      Promise.all<UnreadCountsState>(\n        channelChunks.map((channels) => {\n          return new Promise((resolve) => {\n            getMetaPubNub()?.fetchMessages(\n              {\n                channels,\n                count: 1,\n              },\n              (status, fetchMessagesResponse) => {\n                if (status && status.error) {\n                  console.warn('PubNub fetchMessages failed:', status.error);\n                  resolve({\n                    total: 0,\n                    conversations: {},\n                  });\n                } else {\n                  resolve(\n                    getMessageCountsForConversations(\n                      fetchMessagesResponse,\n                      metaCustomerChannel,\n                    ),\n                  );\n                }\n              },\n            );\n          });\n        }),\n      ).then((countResponses) => {\n        const allCounts = countResponses.reduce(\n          (accum, count) => {\n            Object.assign(accum.conversations, count.conversations);\n            accum.total += count.total;\n            return accum;\n          },\n          {\n            total: 0,\n            conversations: {},\n          },\n        );\n        addUnreadCountsToStore(allCounts);\n        if (typeof cb === 'function') cb();\n        return allCounts;\n      }).catch((error) => {\n        console.warn('Error fetching unread counts:', error);\n        if (typeof cb === 'function') cb();\n      });\n    },\n  );\n};\n","import { backoffAuthCall } from 'core_main/api/pubnub';\nimport { updateStore } from 'core_main/store';\nimport { getConversationPubNub, getMetaPubNub } from './instance';\n\n/*\n  This helper handles the nitty-gritty of refreshing the Pubnub grant token based on the ttl\n*/\nlet authTokenInterval: NodeJS.Timeout;\nlet authTokenExpiration: Date;\n\nexport function computeGrantTokenExpiration(ttl: number) {\n  const buffer = ttl / 10;\n  return ttl - buffer;\n}\n\nexport function refreshGrantToken(outboundChatEnabled) {\n  return backoffAuthCall({ version: 2, outboundChatEnabled }).then(\n    (authResponse) => {\n      // return without continuing to initialize the pubnub instance\n      // because the auth returned an empty response which means there are no existing conversations\n      if (!authResponse) return undefined;\n      getMetaPubNub()?.instance?.setToken(authResponse.token);\n      getConversationPubNub()?.instance?.setToken(authResponse.token);\n      authTokenExpiration = new Date(\n        new Date().getTime() + computeGrantTokenExpiration(authResponse.ttl),\n      );\n      return authResponse;\n    },\n  );\n}\nexport function tryToRefreshToken(outboundChatEnabled) {\n  return refreshGrantToken(outboundChatEnabled).catch(() => {\n    updateStore('isPubNubConnected', false);\n  });\n}\nexport function setupGrantTokenRefresh(outboundChatEnabled) {\n  return refreshGrantToken(outboundChatEnabled).then((authResponse) => {\n    // return without continuing to initialize the pubnub instance\n    // because the auth returned an empty response which means there are no existing conversations\n    if (!authResponse) return undefined;\n    authTokenInterval = setInterval(\n      () => tryToRefreshToken(outboundChatEnabled),\n      computeGrantTokenExpiration(authResponse.ttl),\n    );\n    return authResponse;\n  });\n}\n\nexport function isAuthTokenExpired() {\n  return authTokenExpiration && new Date() > authTokenExpiration;\n}\n\nexport function teardownGrantTokenRefresh() {\n  clearInterval(authTokenInterval);\n}\n","import { runListenersForEvent as chatMessageReceivedHelpers } from 'core_main/globals/events';\nimport { ON_MESSAGE_RECEIVED_EVENT_TYPE } from 'core/constants';\nimport { createMessageCallbackResponse } from 'core_main/sdk/send_message/helpers';\nimport {\n  ChatMessagesData,\n  GetChatMessageAttachmentsData,\n} from 'core_main/api/messages/types';\nimport { incrementUnreadCountInStore } from 'core_main/store';\n\nimport { runListenersForOnUnreadCountChangeEvent } from 'core_main/sdk/mark_read/helpers';\nimport { Included } from '../types';\n\nexport const runListenersForOnMessageReceivedEvent = (\n  message: ChatMessagesData,\n  attachmentData?: GetChatMessageAttachmentsData[],\n  includedData?: Included[],\n  shouldIncrementUnreadCount = true,\n) => {\n  const messageCallbackResponse = createMessageCallbackResponse(\n    message,\n    attachmentData,\n    includedData,\n  );\n\n  const sessionId = message.relationships.session.data.id;\n\n  if (shouldIncrementUnreadCount) {\n    incrementUnreadCountInStore(sessionId);\n    runListenersForOnUnreadCountChangeEvent(sessionId);\n  }\n\n  chatMessageReceivedHelpers(\n    ON_MESSAGE_RECEIVED_EVENT_TYPE,\n    messageCallbackResponse,\n  );\n};\n","import { delayFetchMessageAttachments } from 'core_main/api/messages';\nimport { updateSessionMessages } from 'core_main/api/sessions';\nimport Pubnub from 'pubnub';\nimport { runListenersForOnMessageReceivedEvent } from '../helpers/chatMessageReceived';\nimport { getMetaPubNub } from '../helpers/instance';\n\n// Track processed messages to prevent duplicate unread count increments\n// Key format: messageId:timetoken to handle duplicate PubNub events\nconst processedMessages = new Set<string>();\n\n// Export function to reset processed messages for testing\nexport const resetProcessedMessages = () => {\n  processedMessages.clear();\n};\n\nexport const markMessagesAsDelivered = (\n  messageEvents: any[],\n  sessionId: string,\n) => {\n  const messageIds: string[] = [];\n\n  messageEvents.forEach((messageEvent) => {\n    const { timetoken: messageTimetoken, channel, message } = messageEvent;\n\n    const { id } = message.data;\n\n    messageIds.push(id);\n\n    getMetaPubNub()?.instance?.addMessageAction({\n      channel,\n      messageTimetoken,\n      action: {\n        type: 'delivery',\n        value: 'success',\n      },\n    });\n  });\n\n  updateSessionMessages({\n    sessionId,\n    messageIds,\n    body: { delivered: true },\n  });\n};\n\nexport const handleChatMessageReceivedEvent = (\n  messageEvent: Pubnub.MessageEvent,\n) => {\n  const { message } = messageEvent;\n\n  const { attachments, session } = message.data.relationships;\n  const messageData = message.data;\n  const { included } = message;\n  const { id: messageId, attributes } = messageData;\n  const { firstRead } = attributes;\n\n  const sessionId = session.data.id;\n  const { direction } = attributes;\n\n  // Create unique key for deduplication using messageId and timetoken\n  const messageKey = `${messageId}:${messageEvent.timetoken}`;\n\n  // Check if this message has already been processed to prevent duplicate unread count increments\n  if (processedMessages.has(messageKey)) {\n    return;\n  }\n\n  // Mark message as processed\n  processedMessages.add(messageKey);\n\n  // Determine if we should increment unread count based on direction and firstRead status\n  // 'out' = message from user to customer (incoming to customer) → increment\n  // 'in' = message from customer to user (outgoing from customer) → don't increment\n  // Also check that firstRead is not defined or is empty (no properties)\n  const isFirstReadEmpty = !firstRead || Object.keys(firstRead).length === 0;\n  const shouldIncrementUnreadCount = direction === 'out' && isFirstReadEmpty;\n\n  if (direction === 'out') {\n    markMessagesAsDelivered([messageEvent], sessionId);\n  }\n\n  if (attachments?.data?.length) {\n    delayFetchMessageAttachments(messageId).then((response) => {\n      const attachmentData = response.data;\n      runListenersForOnMessageReceivedEvent(\n        messageData,\n        attachmentData,\n        included,\n        shouldIncrementUnreadCount,\n      );\n    });\n\n    return;\n  }\n\n  runListenersForOnMessageReceivedEvent(messageData, undefined, included, shouldIncrementUnreadCount);\n};\n","import { DEFAULT_PUBNUB_MESSAGE_PAGE_SIZE } from 'core/constants';\nimport { ChatMessagesData } from 'core_main/api/messages/types';\nimport { getStore } from 'core_main/store';\nimport { PublicCallback } from 'globals/types';\nimport { handleError } from 'globals/errors';\nimport Pubnub from 'pubnub';\nimport { fetchAndUpdateCurrentUnreadCounts } from 'core_main/api/customers';\nimport { getConversationPubNub } from '../helpers/instance';\nimport { PUBNUB_ERROR_CATEGORIES } from '../constants';\nimport { fetchUnreadCount } from '../helpers/fetchUnreadCount';\nimport { createConversationChannelGroupString } from '../helpers/channelName';\nimport { markMessagesAsDelivered } from './chatMessageReceived';\n\nexport const markAllMessagesAsDelivered = () => {\n  const store = getStore();\n\n  const { orgId, customerId } = store;\n\n  const channelGroup = createConversationChannelGroupString(customerId, orgId);\n\n  getConversationPubNub()?.listChannels(\n    { channelGroup },\n    (response: Pubnub.ListChannelsResponse) => {\n      response.channels.forEach((channel) => {\n        getConversationPubNub()?.fetchMessages(\n          {\n            channels: [channel],\n            count: DEFAULT_PUBNUB_MESSAGE_PAGE_SIZE,\n            includeMessageActions: true,\n            stringifiedTimeToken: true,\n            start: 0,\n          },\n          (fetchMessagesResponse: Pubnub.FetchMessagesResponse) => {\n            try {\n              const channels = fetchMessagesResponse.channels[channel];\n\n              if (channels?.length) {\n                const messagesToMarkAsDelivered = channels.filter((val) => {\n                  const message: ChatMessagesData = val?.message?.data;\n                  const direction = message?.attributes?.direction;\n\n                  return !val.actions && direction === 'out';\n                });\n\n                if (messagesToMarkAsDelivered.length) {\n                  const sessionId =\n                    messagesToMarkAsDelivered[0]?.message?.data?.relationships\n                      ?.session?.data?.id;\n\n                  markMessagesAsDelivered(messagesToMarkAsDelivered, sessionId);\n                }\n              }\n            } catch (error) {\n              handleError(error, {\n                message: 'Marking all messages as delivered',\n              });\n            }\n          },\n        );\n      });\n    },\n  );\n};\n\nexport const handlePubNubConversationSubscribeOperation = (\n  statusEvent: Pubnub.StatusEvent,\n  orgId: string,\n  customerId: string,\n  cb?: PublicCallback,\n) => {\n  return new Promise((resolve) => {\n    if (PUBNUB_ERROR_CATEGORIES.includes(statusEvent.category)) {\n      resolve(null);\n      return;\n    }\n\n    const { affectedChannelGroups } = statusEvent;\n\n    const conversationChannelGroup = createConversationChannelGroupString(\n      customerId,\n      orgId,\n    );\n\n    if (affectedChannelGroups?.includes(conversationChannelGroup)) {\n      markAllMessagesAsDelivered();\n      const fetchCallback = (allCounts) => {\n        if (typeof cb === 'function') cb(allCounts);\n        resolve(allCounts);\n      };\n      // first try to fetch SessionStats via internal api to get unread count\n      fetchAndUpdateCurrentUnreadCounts()\n        .then(fetchCallback)\n        // if the session stats fetch fails, fallback on PubNub to determine unread count\n        .catch(() => fetchUnreadCount(fetchCallback));\n    } else {\n      resolve(null);\n    }\n  });\n};\n","import { runListenersForEvent as userTypingHelpers } from 'core_main/globals/events';\nimport { ON_AGENT_TYPING_ACTIVITY } from 'core/constants';\nimport { UserAttributes } from 'core_main/api/users/types';\nimport { SignalEvent } from 'pubnub';\n\nimport { UserTypingResponse, UserTypingOptions } from '../types';\nimport { USER_TYPING, AI_ASSISTANT_USER_TYPING } from '../constants';\n\nexport const createUserTypingResponse = (\n  event,\n  user: UserAttributes,\n  typingOpts?: UserTypingOptions,\n): UserTypingResponse => {\n  const { channel, message } = event;\n\n  const conversationId = channel.split('.convo-')[1];\n\n  const typing =\n    message === USER_TYPING || message === AI_ASSISTANT_USER_TYPING;\n\n  return {\n    conversationId,\n    user,\n    typing,\n    typingOpts,\n  };\n};\n\nexport const runListenersForUserTypingEvent = (\n  signalEvent: SignalEvent,\n  user: UserAttributes,\n  opts?: UserTypingOptions,\n) => {\n  const callbackResponse = createUserTypingResponse(signalEvent, user, opts);\n  userTypingHelpers(ON_AGENT_TYPING_ACTIVITY, callbackResponse);\n};\n","import { updateStore } from 'core_main/store';\nimport Pubnub from 'pubnub';\nimport {\n  PUBNUB_ACCESS_DENIED_CATEGORY,\n  PUBNUB_NETWORK_DOWN_CATEGORY,\n  PUBNUB_NETWORK_RECONNECTED_CATEGORY,\n  PUBNUB_NETWORK_UP_CATEGORY,\n} from '../constants';\nimport {\n  isAuthTokenExpired,\n  setupGrantTokenRefresh,\n  teardownGrantTokenRefresh,\n} from '../helpers/grantToken';\n\nexport function createPubnubNetworkStatusEventHandler(outboundChatEnabled) {\n  // this listener returns a promise for ease of testing but pubnub does nto wait for the promise returned to resolve\n  return (statusEvent: Pubnub.StatusEvent) => {\n    const { category } = statusEvent;\n    if (category === PUBNUB_NETWORK_DOWN_CATEGORY) {\n      teardownGrantTokenRefresh();\n    } else if (\n      category === PUBNUB_NETWORK_RECONNECTED_CATEGORY ||\n      category === PUBNUB_NETWORK_UP_CATEGORY ||\n      category === PUBNUB_ACCESS_DENIED_CATEGORY\n    ) {\n      if (isAuthTokenExpired()) {\n        return setupGrantTokenRefresh(outboundChatEnabled).catch(() => {\n          updateStore('isPubNubConnected', false);\n        });\n      }\n    }\n    return Promise.resolve();\n  };\n}\n","import { getStore, updateStore } from 'core_main/store';\nimport { PublicCallback } from 'globals/types';\nimport { handleError } from 'globals/errors';\nimport Pubnub from 'pubnub';\nimport { backoffAuthCall } from 'core_main/api/pubnub';\nimport { handleCustomerDeletedEvent } from 'core_main/pubnub/events/customerDeleted';\nimport { handleChatSessionDeletedEvent } from 'core_main/pubnub/events/chatSessionDelete';\nimport {\n  clearPubNub,\n  getConversationPubNub,\n  getMetaPubNub,\n} from './helpers/instance';\nimport {\n  KUSTOMER_APP_CHAT_CSAT_SEND_EVENT,\n  KUSTOMER_APP_CHAT_MESSAGE_RECEIVE_EVENT,\n  KUSTOMER_APP_CHAT_MESSAGE_SEND_EVENT,\n  KUSTOMER_APP_CHAT_SESSION_DELETE_EVENT,\n  KUSTOMER_APP_CHAT_SESSION_END_EVENT,\n  KUSTOMER_APP_CHAT_SESSION_MERGED_EVENT,\n  KUSTOMER_APP_CHAT_SESSION_UPDATE_EVENT,\n  KUSTOMER_APP_CUSTOMER_DELETED,\n  KUSTOMER_ASSISTANT_CHAT_SESSION_END_EVENT,\n  PUBNUB_SUBSCRIBE_OPERATION,\n  USER_TYPING,\n  USER_TYPING_ENDED,\n  AI_ASSISTANT_USER_TYPING,\n} from './constants';\nimport { handlePubNubConversationSubscribeOperation } from './events/conversationSubscribeOperation';\nimport {\n  createConversationChannelGroupString,\n  createMetaCustomerChannelString,\n} from './helpers/channelName';\n\nimport { InitializePubNubParameters } from './types';\nimport { handleChatMessageReceivedEvent } from './events/chatMessageReceived';\nimport { handleChatSessionUpdateEvent } from './events/chatSessionUpdate';\nimport { handleChatSessionMergedEvent } from './events/chatSessionMerged';\nimport { handleChatSessionEndedEvent } from './events/chatSessionEnded';\nimport { handleAssistantSessionEndedEvent } from './events/assistantSessionEnded';\nimport { handleChatCsatSendEvent } from './events/chatCsatSend';\nimport { handleUserTypingEvent } from './events/userTyping';\nimport { createPubnubNetworkStatusEventHandler } from './events/networkStatus';\nimport {\n  setupGrantTokenRefresh,\n  teardownGrantTokenRefresh,\n} from './helpers/grantToken';\n\nexport {\n  getConversationPubNub,\n  getMetaPubNub,\n  clearPubNub,\n  stopPubNub,\n} from './helpers/instance';\n\nexport const createPubNubMetaListeners = (outboundChatEnabled) => ({\n  message: (messageEvent: Pubnub.MessageEvent) => {\n    const { message } = messageEvent;\n\n    const { name } = message;\n\n    try {\n      switch (name) {\n        case KUSTOMER_APP_CHAT_SESSION_END_EVENT:\n          handleChatSessionEndedEvent(message);\n          break;\n        case KUSTOMER_ASSISTANT_CHAT_SESSION_END_EVENT:\n          handleAssistantSessionEndedEvent(message);\n          break;\n        case KUSTOMER_APP_CHAT_SESSION_UPDATE_EVENT:\n          handleChatSessionUpdateEvent(message);\n          break;\n        case KUSTOMER_APP_CHAT_SESSION_MERGED_EVENT:\n          handleChatSessionMergedEvent(message);\n          break;\n        case KUSTOMER_APP_CUSTOMER_DELETED:\n          handleCustomerDeletedEvent();\n          break;\n        case KUSTOMER_APP_CHAT_SESSION_DELETE_EVENT:\n          handleChatSessionDeletedEvent(message);\n          break;\n        default:\n          break;\n      }\n    } catch (e) {\n      handleError(e);\n    }\n  },\n  signal: (signalEvent) => {\n    const { message } = signalEvent;\n\n    switch (message) {\n      case USER_TYPING:\n      case AI_ASSISTANT_USER_TYPING:\n      case USER_TYPING_ENDED: {\n        handleUserTypingEvent(signalEvent, {\n          isAIGeneratingAnswer: message === AI_ASSISTANT_USER_TYPING,\n        });\n        break;\n      }\n      default:\n        break;\n    }\n  },\n  status: createPubnubNetworkStatusEventHandler(outboundChatEnabled),\n});\n\nexport const createPubNubConversationListeners = (\n  customerId: string,\n  orgId: string,\n  cb?: PublicCallback,\n) => ({\n  message: (messageEvent: Pubnub.MessageEvent) => {\n    const { message, timetoken } = messageEvent;\n\n    const { name } = message;\n\n    try {\n      switch (name) {\n        case KUSTOMER_APP_CHAT_MESSAGE_RECEIVE_EVENT:\n          handleChatMessageReceivedEvent(messageEvent);\n          break;\n        case KUSTOMER_APP_CHAT_MESSAGE_SEND_EVENT:\n          handleChatMessageReceivedEvent(messageEvent);\n          break;\n        case KUSTOMER_APP_CHAT_CSAT_SEND_EVENT:\n          handleChatCsatSendEvent(message, timetoken);\n          break;\n        default:\n          break;\n      }\n    } catch (e) {\n      handleError(e);\n    }\n  },\n  status: (statusEvent: Pubnub.StatusEvent) => {\n    const { operation } = statusEvent;\n\n    if (operation === PUBNUB_SUBSCRIBE_OPERATION) {\n      handlePubNubConversationSubscribeOperation(\n        statusEvent,\n        orgId,\n        customerId,\n        cb,\n      );\n    }\n  },\n});\n\nexport const initializePubNub = ({\n  customerId,\n  orgId,\n  cb,\n}: InitializePubNubParameters) => {\n  const store = getStore();\n\n  const { settings } = store;\n\n  const { outboundChatEnabled } = settings;\n\n  if (!customerId || !orgId || store.isPubNubConnected) {\n    if (typeof cb === 'function') cb();\n    return Promise.resolve();\n  }\n\n  teardownGrantTokenRefresh();\n  clearPubNub();\n\n  return setupGrantTokenRefresh(outboundChatEnabled)\n    .catch(() => {\n      // if an unrecoverable error occurs, try v1 auth\n      return backoffAuthCall({ version: 1, outboundChatEnabled: false });\n    })\n    .then((authResponse) => {\n      if (!authResponse) {\n        if (typeof cb === 'function') cb();\n        return;\n      }\n\n      getMetaPubNub()?.instance?.addListener(\n        createPubNubMetaListeners(outboundChatEnabled),\n      );\n\n      getConversationPubNub()?.instance?.addListener(\n        createPubNubConversationListeners(customerId, orgId, cb),\n      );\n\n      updateStore('isPubNubConnected', true);\n\n      const channelGroupString = createConversationChannelGroupString(\n        customerId,\n        orgId,\n      );\n      const customerMetaChannel = createMetaCustomerChannelString(\n        customerId,\n        orgId,\n      );\n\n      getConversationPubNub()?.instance?.subscribe({\n        channelGroups: [channelGroupString],\n      });\n      getMetaPubNub()?.instance?.subscribe({\n        channels: [customerMetaChannel],\n      });\n    });\n};\n","import { ON_CONVERSATION_ENDED_EVENT_TYPE } from 'core/constants';\nimport { runListenersForEvent } from 'core_main/globals/events';\nimport { createEndConversationCallbackResponse } from 'core_main/sdk/end_conversation/helpers';\nimport { PubNubSessionEndMessageEvent } from '../types';\n\nexport const handleChatSessionEndedEvent = (\n  message: PubNubSessionEndMessageEvent,\n) => {\n  const callbackResponse = createEndConversationCallbackResponse(message.data);\n\n  runListenersForEvent(ON_CONVERSATION_ENDED_EVENT_TYPE, callbackResponse);\n};\n","import { ON_ASSISTANT_ENDED_EVENT_TYPE } from 'core/constants';\nimport { ChatSessionsData } from 'core_main/api/sessions/types';\nimport { runListenersForEvent } from 'core_main/globals/events';\nimport { ConversationCallbackResponse } from 'core_main/sdk/types';\nimport { PubNubSessionEndMessageEvent } from '../types';\n\nexport const createEndAssistantCallbackResponse = (\n  data: ChatSessionsData,\n): ConversationCallbackResponse => {\n  const { id: conversationId } = data;\n  const { isInAssistantMode } = data.attributes;\n  return {\n    conversationId,\n    isInAssistantMode,\n  };\n};\n\nexport const handleAssistantSessionEndedEvent = (\n  message: PubNubSessionEndMessageEvent,\n) => {\n  const callbackResponse = createEndAssistantCallbackResponse(message.data);\n\n  runListenersForEvent(ON_ASSISTANT_ENDED_EVENT_TYPE, callbackResponse);\n};\n","import { ON_CONVERSATION_UNENDED_EVENT_TYPE } from 'core/constants';\nimport { runListenersForEvent } from 'core_main/globals/events';\nimport { getKustomerMainObject } from 'core_main/globals/helpers';\nimport { createEndConversationCallbackResponse } from 'core_main/sdk/end_conversation/helpers';\nimport { PubNubSessionUpdateMessageEvent } from '../types';\n\nexport const handleChatSessionUpdateEvent = (\n  message: PubNubSessionUpdateMessageEvent,\n) => {\n  const lockedAtOp = message?.data?.changes?.attributes?.lockedAt?.op;\n\n  const before = message?.data?.before;\n  const after = message?.data?.after;\n\n  const beforeCustomerId = before?.relationships?.customer?.data?.id;\n  const afterCustomerId = after?.relationships?.customer?.data?.id;\n\n  if (\n    beforeCustomerId &&\n    beforeCustomerId !== afterCustomerId &&\n    afterCustomerId\n  ) {\n    setTimeout(() => {\n      const kustomerMain = getKustomerMainObject();\n      kustomerMain.login();\n    }, 400);\n  }\n\n  if (!lockedAtOp) return;\n\n  if (lockedAtOp === 'remove') {\n    const callbackResponse = createEndConversationCallbackResponse(after);\n\n    runListenersForEvent(ON_CONVERSATION_UNENDED_EVENT_TYPE, callbackResponse);\n  }\n};\n","import { ON_CONVERSATION_MERGED_EVENT_TYPE } from 'core/constants';\nimport { runListenersForEvent } from 'core_main/globals/events';\nimport {\n  ConversationMergedCallbackResponse,\n  PubNubChatSessionMergedMessageEvent,\n} from '../types';\n\nexport const createChatSessionMergedCallbackResponse = (\n  event: PubNubChatSessionMergedMessageEvent,\n): ConversationMergedCallbackResponse => {\n  const { data } = event;\n  const { relationships } = data;\n  const { source, target } = relationships;\n  const { id: sourceId } = source.data;\n  const { id: targetId } = target.data;\n\n  return {\n    sourceConversationId: sourceId,\n    targetConversationId: targetId,\n  };\n};\n\nexport const handleChatSessionMergedEvent = (\n  message: PubNubChatSessionMergedMessageEvent,\n) => {\n  const callbackResponse = createChatSessionMergedCallbackResponse(message);\n\n  runListenersForEvent(ON_CONVERSATION_MERGED_EVENT_TYPE, callbackResponse);\n};\n","import { runListenersForEvent } from 'core_main/globals/events';\nimport { ON_CUSTOMER_DELETE_EVENT_TYPE } from 'core/constants';\n\nexport const handleCustomerDeletedEvent = () => {\n  runListenersForEvent(ON_CUSTOMER_DELETE_EVENT_TYPE);\n};\n","import { PubNubChatSessionDeletedMessageEvent } from 'core_main/pubnub/types';\nimport { runListenersForEvent } from 'core_main/globals/events';\nimport { ON_CONVERSATION_DELETED_EVENT_TYPE } from 'core/constants';\n\nexport const handleChatSessionDeletedEvent = (\n  message: PubNubChatSessionDeletedMessageEvent,\n) => {\n  const { id } = message.data;\n  const callbackResponse = {\n    conversationId: id,\n  };\n\n  runListenersForEvent(ON_CONVERSATION_DELETED_EVENT_TYPE, callbackResponse);\n};\n","import { getUser } from 'core_main/api/users';\nimport { getUserFromStore } from 'core_main/store';\nimport Pubnub from 'pubnub';\nimport { runListenersForUserTypingEvent } from '../helpers/userTyping';\n\nexport const handleUserTypingEvent = (\n  signalEvent: Pubnub.SignalEvent,\n  typingOpts,\n) => {\n  const user = getUserFromStore(signalEvent.publisher);\n\n  if (user) {\n    runListenersForUserTypingEvent(signalEvent, user, typingOpts);\n  } else {\n    getUser(signalEvent.publisher).then((res) => {\n      runListenersForUserTypingEvent(\n        signalEvent,\n        res.data.attributes,\n        typingOpts,\n      );\n    });\n  }\n};\n","import { get } from 'core_main/request';\nimport { addUserToStore } from 'core_main/store';\nimport { makeUserEndpoint } from './helpers';\n\nexport const getUser = (userId: string) => {\n  return get(makeUserEndpoint(userId)).then((response) => {\n    const { id } = response.data;\n    const { attributes } = response.data;\n\n    addUserToStore(id, attributes);\n\n    return response;\n  });\n};\n","import { USER_ENDPOINT } from './constants';\n\nexport const makeUserEndpoint = (id: string) => {\n  return `/c/v1/users/${id}` as typeof USER_ENDPOINT;\n};\n","import { ON_SATISFACTION_RECEIVED_EVENT_TYPE } from 'core/constants';\nimport { createSatisfactionCallbackResponse } from 'core_main/api/satisfaction/helpers';\nimport { runListenersForEvent } from 'core_main/globals/events';\nimport Pubnub from 'pubnub';\nimport { PubNubCsatSendMessageEvent } from '../types';\n\nexport const handleChatCsatSendEvent = (\n  message: PubNubCsatSendMessageEvent,\n  timetoken: Pubnub.MessageEvent['timetoken'],\n) => {\n  const { included } = message;\n\n  const form = included?.find((entity) => entity.type === 'satisfaction');\n\n  const callbackResponse = createSatisfactionCallbackResponse(\n    message.data,\n    timetoken,\n    form,\n  );\n\n  runListenersForEvent(ON_SATISFACTION_RECEIVED_EVENT_TYPE, callbackResponse);\n};\n"],"names":["backoffAuthCall","options","retryCount","arguments","length","undefined","delay","version","post","body","JSON","stringify","authVerified","outboundChatEnabled","then","response","_response$data$attrib","_response$data$attrib2","_response$data$attrib3","data","token","attributes","sharedKeyset","ttl","createAuthForTrackingToken","catch","error","isNotPubNubNetworkFailure","title","Promise","reject","resolve","setTimeout","res","Error","PubNubMetaInstance","PubNubConversationInstance","PubNubInstance","_createClass","_this","_classCallCheck","_defineProperty","listChannelsParameters","cb","_this$instance","instance","channelGroups","listChannels","status","fetchMessagesParameters","_this$instance2","fetchMessages","messageCountsParameters","_this$instance3","messageCounts","store","getStore","_store$settings$share","settings","sharedPubNubKeySet","publishKey","subscribeKey","customerId","trackingToken","getTrackingTokenFromLocalStorage","this","Pubnub","uuid","authKey","restore","ssl","getMetaPubNub","getConversationPubNub","clearPubNub","_PubNubMetaInstance$i","_PubNubConversationIn","unsubscribeAll","stopPubNub","_PubNubMetaInstance$i2","_PubNubConversationIn2","stop","authTokenInterval","authTokenExpiration","runListenersForOnMessageReceivedEvent","message","attachmentData","includedData","shouldIncrementUnreadCount","messageCallbackResponse","createMessageCallbackResponse","sessionId","relationships","session","id","incrementUnreadCountInStore","runListenersForOnUnreadCountChangeEvent","chatMessageReceivedHelpers","ON_MESSAGE_RECEIVED_EVENT_TYPE","processedMessages","Set","markMessagesAsDelivered","messageEvents","messageIds","forEach","messageEvent","_getMetaPubNub","_getMetaPubNub$instan","messageTimetoken","timetoken","channel","push","addMessageAction","action","type","value","updateSessionMessages","delivered","handlePubNubConversationSubscribeOperation","statusEvent","orgId","PUBNUB_ERROR_CATEGORIES","includes","category","affectedChannelGroups","conversationChannelGroup","createConversationChannelGroupString","_getConversationPubNu","channelGroup","channels","_getConversationPubNu2","count","DEFAULT_PUBNUB_MESSAGE_PAGE_SIZE","includeMessageActions","stringifiedTimeToken","start","fetchMessagesResponse","messagesToMarkAsDelivered","filter","val","_val$message","_message$attributes","direction","actions","_messagesToMarkAsDeli","_messagesToMarkAsDeli2","_messagesToMarkAsDeli3","_messagesToMarkAsDeli4","_messagesToMarkAsDeli5","_messagesToMarkAsDeli6","handleError","markAllMessagesAsDelivered","fetchCallback","allCounts","fetchAndUpdateCurrentUnreadCounts","metaCustomerChannel","createMetaCustomerChannelString","console","warn","metaChannels","map","replace","channelChunks","chunk","concat","_toConsumableArray","PUBNUB_MAX_CHANNELS_COUNT","all","total","conversations","metaCustomerChannelName","noHistory","metaCustomerChannelMessages","ignoredIds","name","KUSTOMER_APP_CHAT_SESSION_END_EVENT","lastReadMessages","Object","keys","split","reduce","acc","lastReadMessage","reverse","find","eventType","counts","index","isLast","channelName","channelTimetokens","getMessageCountsForConversations","countResponses","accum","assign","addUnreadCountsToStore","fetchUnreadCount","runListenersForUserTypingEvent","signalEvent","user","opts","callbackResponse","event","typingOpts","conversationId","typing","USER_TYPING","AI_ASSISTANT_USER_TYPING","createUserTypingResponse","userTypingHelpers","ON_AGENT_TYPING_ACTIVITY","computeGrantTokenExpiration","refreshGrantToken","authResponse","setToken","Date","getTime","setupGrantTokenRefresh","setInterval","updateStore","tryToRefreshToken","teardownGrantTokenRefresh","clearInterval","createPubnubNetworkStatusEventHandler","PUBNUB_NETWORK_DOWN_CATEGORY","PUBNUB_NETWORK_RECONNECTED_CATEGORY","PUBNUB_NETWORK_UP_CATEGORY","PUBNUB_ACCESS_DENIED_CATEGORY","createPubNubMetaListeners","createEndConversationCallbackResponse","runListenersForEvent","ON_CONVERSATION_ENDED_EVENT_TYPE","handleChatSessionEndedEvent","KUSTOMER_ASSISTANT_CHAT_SESSION_END_EVENT","isInAssistantMode","ON_ASSISTANT_ENDED_EVENT_TYPE","handleAssistantSessionEndedEvent","KUSTOMER_APP_CHAT_SESSION_UPDATE_EVENT","_message$data","_message$data$changes","_message$data$changes2","_message$data$changes3","_message$data2","_message$data3","_before$relationships","_before$relationships2","_before$relationships3","_after$relationships","_after$relationships$","_after$relationships$2","lockedAtOp","changes","lockedAt","op","before","after","beforeCustomerId","customer","afterCustomerId","getKustomerMainObject","login","ON_CONVERSATION_UNENDED_EVENT_TYPE","handleChatSessionUpdateEvent","KUSTOMER_APP_CHAT_SESSION_MERGED_EVENT","source","target","sourceConversationId","targetConversationId","ON_CONVERSATION_MERGED_EVENT_TYPE","handleChatSessionMergedEvent","KUSTOMER_APP_CUSTOMER_DELETED","ON_CUSTOMER_DELETE_EVENT_TYPE","KUSTOMER_APP_CHAT_SESSION_DELETE_EVENT","ON_CONVERSATION_DELETED_EVENT_TYPE","handleChatSessionDeletedEvent","e","signal","USER_TYPING_ENDED","userId","getUserFromStore","publisher","get","addUserToStore","handleUserTypingEvent","isAIGeneratingAnswer","createPubNubConversationListeners","KUSTOMER_APP_CHAT_MESSAGE_RECEIVE_EVENT","KUSTOMER_APP_CHAT_MESSAGE_SEND_EVENT","_attachments$data","_message$data$relatio","attachments","messageData","included","messageId","firstRead","messageKey","has","add","isFirstReadEmpty","delayFetchMessageAttachments","handleChatMessageReceivedEvent","KUSTOMER_APP_CHAT_CSAT_SEND_EVENT","form","entity","createSatisfactionCallbackResponse","ON_SATISFACTION_RECEIVED_EVENT_TYPE","handleChatCsatSendEvent","operation","PUBNUB_SUBSCRIBE_OPERATION","initializePubNub","_ref","isPubNubConnected","_getConversationPubNu3","_getConversationPubNu4","_getMetaPubNub2","_getMetaPubNub2$insta","addListener","channelGroupString","customerMetaChannel","subscribe"],"sourceRoot":""}